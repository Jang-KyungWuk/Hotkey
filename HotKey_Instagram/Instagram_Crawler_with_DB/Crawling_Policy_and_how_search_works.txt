크롤링 예외처리 -------------------------------------
1. 로그인 결과 다음과 같은 status를 반환한다 : 
status = 0 : success , 1 : checkpoint_needed 에러 (수동 인증 필요), 2 : incorrect pw 에러 (계정 임시 차단), 3. CSRF 에러 (IP문제), 4. 그 외

2. 크롤링 결과 다음과 같은 status를 반환한다 :
status = 0 : success, 1 : 크롤링 중 문제 발생 (CSRF error), code는 200 , 2 : 400error - 계정에 checkpoint 필요,
            3 : 검열 혹은 페이지 x,  4 : 그 외, 5 : 인스타그램에서 최근 게시물을 제공하지 않는 태그 ( len(recent_list[0]) == 0 )
--------------------------------------------------------
크롤링/Search 정책 ------------------------------------------
*계정정보는 DB로 유지하기 => id, pw, blocked, user_agent, update
request 별로 랜덤하게 sleep, 키워드 당 1분 정도로 천천히
다 막히면 (all_blocked == True) 매뉴얼하게 체크해줘야함. => 서버 코드 유지보수가 가능한가?
*이메일이랑 전화번호를 모두 넣어놔야하는 것으로 보임
#한 개 ip에 최대 2개의 session이 유지되고 있다고 정책 설정.
#한 개 account에 한 개의 user-agent만 unique하게 할당.
#한 개 account로 여러개의 session만들지 않기. (기존 session은 로그아웃해야함)
##한 개의 account 당 최대 연속 3번의 크롤링 시도.
##서버가 할당되고 나면 서비스 개시 이전에 (첫 업데이트 이전)
=> 서버의 IP와 각 user-agent로 로그인 시도 한뒤, 각자 인증에 성공해야함.
-----------------------------------------
*****서비스 게시 전 : **user_agent 다르게 할당해야하므로 gen_headers 등... 함수 및 전체 로직 변경해야함!!
=> 계정별로 다른 user agent 할당, 계정 별로 이메일/전화번호 입력및확인, 코드 상에서 로그인 한 뒤, 각자 매뉴얼하게 인스타그램 가서 로그인 본인 거 인증(IP& user-agent 인증).
***********주기적으로 account관리 (DB에서 매뉴얼하게 상태 확인.), all_blocked이면 IP문제인지 각 계정문제인지 매뉴얼하게 확인해야함.
#all_blocked인 경우에 30분~1시간 정도 주기적으로 로그인 시도(+로그아웃)해보면서 total_acc_info랑 all_blocked수정하기. => 주기적으로 check_avail()실행.
***관리 후 total_acc_info, sessions, all_blocked, acc_inuse 초기화 해주는 함수 서버에서 구현
=> @app.route( /manage/~) 루트로 관리하는 각종 코드 넣어두기
-----
전체 acc개수 (실제 서비스 구현시) : 6개라고 가정
total_acc_info = [ {'id','pw', agent, blocked} ] * 6 (agent=id별 고유한 user-agent)

sessions = [({session, inuse, last_time, logout, usage, orig_idx} * 6 ] True일 경우 현재 세션이 유지되고 있음, False일 경우 현재 세션 존재 x) timestamp = int(datetime.now().timestamp()) ; False일 경우 빈 세션 = Session()이 들어간다. usage = 최대 5번까지 가능.
orig_idx = 해당 세션을 생성한 account의 total_acc_info에서의 index.

all_blocked = 전부 막혔는지 여부

acc_inuse = [{'session', orig_idx} 최대 2개]
keyword검색 요청이 들어오고 크롤링이 필요할 경우
*import copy 필요
=> 사용되고 있는 세션 중에서
 => last_time과 현재 timestamp와의 차이가 1시간 이상일경우 로그아웃(로그아웃 중 발생하는 예외는 상관없음. 세션 만료),
    usage가 3 초과일 경우 로그아웃,      
    usage=0, session = Session(), status = False, last_time = 0, logout = int(datetime.now().timestamp())
 => 로그아웃 하나 될 때 마다, 계정 하나 로그인. 기준은 int(datetime.now().timestamp()) - logout이 가장 큰 거 부터.
     => 로그인 시 에러 발생하면 total_acc_info에서 blocked = True, acc_info에서 해당 account삭제, sessions에서 해당 session삭제
 => (현재 로그인 되어있는 세션 두개는 usage가 5 이하이고 마지막 사용으로부터 한 시간 이내.)

=> 활용 가능한 세션 준비에 문제가 없으면 크롤링 시작.
=> 크롤링이 끝나면 사용한 session의 last_time = int(datetime.now().timestamp())
-----
### user-agent 모음
1 : Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.56   
=>  본인 노트북 Edge (계속 사용중)
2 : Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36
=> 본인 노트북 Chrome (계속 사용중)
3 : Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/525.18 (KHTML, like Gecko) Version/3.1.1 Safari/525.17
4 : Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3
5 : Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.19582
6 : Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.68 Safari/534.24

--
aid 5까지 blocked false
aid 8이랑 9도 blocked false로 업데이트